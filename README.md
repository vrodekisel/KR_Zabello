# Серверная часть системы внутриигрового голосования за контент

Курсовой проект: backend веб‑приложения для внутриигровой системы голосования за пользовательский контент
(карты и модификации).

## Описание

Проект реализует серверную часть системы, которая:

- предоставляет REST API для внутриигрового клиента;
- содержит веб‑интерфейс (админка + демо‑клиент) для работы через браузер;
- хранит и обрабатывает данные о пользователях, опросах, вариантах и голосах;
- рассчитывает рейтинги контента и защищает голосования от накрутки.

Важно: сайт рассматривается как **один из клиентов внутриигровой системы**, а не как отдельный
агрегатор отзывов. Основной сценарий использования — запрос оценок у игроков прямо в игре
(после матча или через меню), с сохранением всех голосов на сервере.

## Основные возможности

- Регистрация и авторизация пользователей.
- Управление опросами (создание, просмотр списка, просмотр деталей).
- Голосование пользователей за варианты опроса (карты / моды).
- Получение результатов голосования и рейтингов контента.
- Базовая защита от накрутки:
  - один голос пользователя в рамках одного опроса;
  - логирование попыток голосования (user_id, poll_id, IP, user-agent, время, статус);
  - возможность реализовать лимиты «слишком много голосов за короткий период» на уровне доменного сервиса.
- Поддержка локализации: все текстовые поля в БД хранятся как **ключи локализации**, а не как
  готовые строки (polls.title, polls.description, options.label, причины в логах и т.п.).

## Технологический стек

- **Язык**: PHP 8.x
- **Веб‑сервер**: Apache (запуск в контейнере)
- **База данных**: MySQL
- **Архитектура**: упрощённая Clean Architecture (слои HTTP / Application / Domain / Infrastructure)
- **Контейнеризация**: Docker, docker-compose
- **Тестирование**: PHPUnit
- **Локализация**: собственный класс `Translator` и файловые словари с ключами/строками

## Архитектура (слои)

- **HTTP** (`src/Http`)
  - Контроллеры REST API: `AuthController`, `PollController`, `VoteController`.
  - HTML‑клиент (веб‑интерфейс): `WebAuthController`, `WebPollController`, `WebAdminPollController`,
    `WebAdminPollDetailsController`.
  - Роутер `Router`, который сопоставляет HTTP‑методы и пути с обработчиками.

- **Application** (`src/Application`)
  - UseCase‑сервисы, инкапсулирующие сценарии:
    - `CreatePollService`
    - `CastVoteService`
    - `GetPollResultsService`
  - DTO и запросы/ответы для этих сценариев.

- **Domain** (`src/Domain`)
  - Сущности:
    - `User`
    - `Poll`
    - `Option`
    - `Vote`
  - Интерфейсы репозиториев:
    - `UserRepository`
    - `PollRepository`
    - `VoteRepository`
  - Доменный сервис:
    - `VotePolicyService` — инкапсулирует правила голосования и защиту от накрутки.

- **Infrastructure** (`src/Infrastructure`)
  - Слой работы с БД:
    - `MySQLConnection`
    - `MySQLUserRepository`
    - `MySQLPollRepository`
    - `MySQLVoteRepository`
  - Логирование:
    - `FileLogger` (журнал голосований и ошибок).
  - Поддерживающие классы (адаптеры, реализация интерфейсов домена и т.п.).

- **Вспомогательные компоненты**
  - `App\Localization\Translator` — загрузка строк по ключам локализации.
  - `App\View\View` — простой рендер HTML‑шаблонов для веб‑интерфейса.

## Структура проекта

Упрощённая структура каталогов:

```text
project-root/
├─ public/
│  └─ index.php
├─ src/
│  ├─ Http/
│  │  ├─ Router.php
│  │  └─ Controller/
│  │     ├─ AuthController.php
│  │     ├─ PollController.php
│  │     ├─ VoteController.php
│  │     ├─ WebAuthController.php
│  │     ├─ WebPollController.php
│  │     ├─ WebAdminPollController.php
│  │     └─ WebAdminPollDetailsController.php
│  ├─ Application/
│  │  └─ UseCase/
│  │     ├─ CreatePoll/
│  │     ├─ CastVote/
│  │     └─ GetPollResults/
│  ├─ Domain/
│  │  ├─ Entity/
│  │  │  ├─ User.php
│  │  │  ├─ Poll.php
│  │  │  ├─ Option.php
│  │  │  └─ Vote.php
│  │  ├─ Repository/
│  │  │  ├─ UserRepository.php
│  │  │  ├─ PollRepository.php
│  │  │  └─ VoteRepository.php
│  │  └─ Service/
│  │     └─ VotePolicyService.php
│  ├─ Infrastructure/
│  │  ├─ Persistence/
│  │  │  ├─ MySQLConnection.php
│  │  │  ├─ MySQLUserRepository.php
│  │  │  ├─ MySQLPollRepository.php
│  │  │  └─ MySQLVoteRepository.php
│  │  └─ Logging/
│  │     └─ FileLogger.php
│  ├─ Localization/
│  │  └─ Translator.php
│  └─ View/
│     └─ View.php
├─ config/
│  ├─ config.php
│  └─ db.php
├─ database/
│  ├─ schema.sql
│  └─ seed.sql
├─ docker/
│  ├─ apache-vhost.conf
│  └─ Dockerfile
├─ tests/
│  └─ Unit/...
├─ storage/
│  └─ logs/...
├─ docker-compose.yml
├─ composer.json
├─ phpunit.xml
├─ .env.example
└─ README.md
```

Фактическая структура может немного отличаться, но общие принципы соответствуют Clean Architecture:
внешний слой зависит от внутреннего, а не наоборот.

## Требования

- PHP 8.2+
- Composer
- MySQL 8.x
- Docker и docker-compose (рекомендуется для быстрого запуска)
- Расширения PHP для работы с PDO/MySQL

## Подготовка окружения (без Docker)

1. Склонировать репозиторий проекта:

   ```bash
   git clone <url-репозитория>
   cd <директория-проекта>
   ```

2. Установить зависимости через Composer:

   ```bash
   composer install
   ```

3. Создать файл окружения:

   ```bash
   cp .env.example .env
   ```

   В `.env` настроить параметры подключения к MySQL (хост, порт, имя БД, пользователь, пароль)
   и дополнительные настройки приложения (язык по умолчанию и т.п.).

4. Создать базу данных в MySQL (имя должно совпадать с тем, что указано в `.env`):

   ```sql
   CREATE DATABASE arena_votes CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
   ```

5. Применить SQL‑скрипты:

   ```bash
   mysql -u <user> -p arena_votes < database/schema.sql
   mysql -u <user> -p arena_votes < database/seed.sql
   ```

   Скрипт `schema.sql` создаёт таблицы, `seed.sql` добавляет демо‑данные (карты, моды, три
   демонстрационных пользователя и т.п.). Все текстовые поля в этих скриптах представлены
   **ключами локализации**, а не готовыми строками.

6. Настроить веб‑сервер (варианты):

   - Запуск через встроенный сервер PHP (для разработки):

     ```bash
     php -S localhost:8000 -t public
     ```

     Приложение будет доступно по адресу: `http://localhost:8000`.

   - Или настроить Apache/Nginx так, чтобы корнем сайта была папка `public/`.

## Запуск через Docker

1. Убедиться, что установлены Docker и docker-compose.

2. В корне проекта создать `.env` (по аналогии с `.env.example`) или использовать переменные,
   ожидаемые `docker-compose.yml`.

3. Запустить контейнеры:

   ```bash
   docker-compose up -d
   ```

4. После успешного поднятия контейнеров:

   - веб‑приложение будет доступно на порту, указанном в `docker-compose.yml`
     (например, `http://localhost:8080`);
   - MySQL будет доступен внутри Docker‑сети; при необходимости можно пробросить порт
     наружу для подключения локального клиента.

5. При первом запуске убедиться, что `schema.sql` и `seed.sql` были выполнены
   (это можно сделать либо вручную, либо через init‑скрипты, если они настроены в compose‑файле).

## Тестирование

Для запуска юнит‑тестов используется PHPUnit.

```bash
composer test
```

Тесты покрывают основные сценарии прикладного уровня:

- создание опроса (`CreatePollService`);
- голосование и проверка правил доменной политики (`CastVoteService` + `VotePolicyService`);
- получение результатов голосования (`GetPollResultsService`).

## Локализация

- Все текстовые поля в БД (например, `polls.title`, `polls.description`, `options.label`)
  хранятся в виде ключей: `poll.map_rotation.title`, `poll.mods_rating.description` и т.п.
- На уровне PHP используется класс `Translator`, который подставляет строки в зависимости от
  выбранной локали (например, `ru`, `en`).
- В веб‑интерфейсе доступно переключение языка; при смене локали интерфейс и подписи
  загружаются из соответствующих файлов локализации.

## Основные REST‑эндпоинты (пример)

Фактический список маршрутов задаётся в `public/index.php` через `Router`, но базовая схема
REST API может выглядеть так:

- `POST /api/auth/register` — регистрация пользователя;
- `POST /api/auth/login` — авторизация, получение токена или сессии;
- `GET  /api/polls` — список активных опросов;
- `GET  /api/polls/{id}` — подробности опроса (варианты ответа);
- `POST /api/polls` — создание опроса (для админ‑пользователей);
- `POST /api/polls/{id}/vote` — отправка голоса за выбранный вариант;
- `GET  /api/polls/{id}/results` — аггрегированные результаты голосования.

Параллельно с REST API реализован HTML‑клиент:

- список опросов и их статусов;
- отдельная страница опроса с формой голосования;
- админ‑раздел для просмотра деталей опроса и логов.

## Типичные сценарии использования

1. **Игрок в игре**:
   - проходит матч в ArenaX;
   - после матча игра запрашивает у сервера список доступных голосований;
   - игрок выбирает карту или мод и отправляет голос через внутриигровой клиент;
   - сервер проверяет права, доменную политику, записывает голос и логирует событие.

2. **Администратор/дизайнер игры**:
   - авторизуется в веб‑интерфейсе;
   - создаёт новый опрос (например, «выбор следующих карт в ротации»);
   - просматривает результаты и рейтинги модов/карт;
   - принимает решения о балансе и контенте на основе статистики.

## Лицензия и авторство

Проект создан в рамках курсовой работы по дисциплине, посвящённой разработке
серверной части веб‑приложений. Код и структура могут использоваться в учебных целях,
а также как основа для дальнейшего развития внутриигровой системы голосования.
